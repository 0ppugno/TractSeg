#!/usr/bin/env python

import argparse
import math

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats

from tractseg.data import dataset_specific_utils
from tractseg.libs.AFQ_MultiCompCorrection import AFQ_MultiCompCorrection
from tractseg.libs.AFQ_MultiCompCorrection import get_significant_areas


def parse_subjects_file(file_path):
    with open(file_path) as f:
        lines = f.readlines()

    base_path = None
    subjects_A = []
    subjects_B = []
    for line in lines:
        l = line.strip()
        if l.startswith("path="):
            base_path = l.split("=")[1]
        elif l.startswith("A_"):
            subjects_A.append(l[2:])
        elif l.startswith("B_"):
            subjects_B.append(l[2:])

    return base_path, subjects_A, subjects_B


def plot_tractometry_with_pvalue(values, subjects_A, subjects_B, bundles, selected_bundles, output_path, alpha,
                                 multcomp=1, nperm=1000):

    NR_POINTS = values[subjects_A[0]].shape[1]
    selected_bun_indices = [bundles.index(b) for b in selected_bundles]

    cols = 5
    rows = math.ceil(len(selected_bundles) / cols)

    a4_dims = (cols*3, rows*5)
    f, axes = plt.subplots(rows, cols, figsize=a4_dims)

    axes = axes.flatten()
    sns.set(font_scale=1.2)
    sns.set_style("whitegrid")

    for i, b_idx in enumerate(selected_bun_indices):

        # Bring data into right format for seaborn
        data = {"position": [],
                "fa": [],
                "group": [],
                "subject": []}
        for j, subject in enumerate(subjects_A + subjects_B):
            for position in range(NR_POINTS):
                data["position"].append(position)
                data["subject"].append(subject)
                data["fa"].append(values[subject][b_idx][position])
                if subject in subjects_A:
                    data["group"].append("Group A")
                else:
                    data["group"].append("Group B")

        # Plot
        ax = sns.lineplot(x="position", y="fa", data=data, ax=axes[i], hue="group")

        ax.set(xlabel='position', ylabel='metric')
        ax.set_title(bundles[b_idx])
        if i > 0:
            ax.legend_.remove()  # only show legend on first subplot

        ################ Significance testing ################
        values_allp = [values[s][b_idx] for s in subjects_A + subjects_B]
        groups = (0,) * len(subjects_A) + (1,) * len(subjects_B)
        alphaFWE, statFWE, clusterFWE, stats = AFQ_MultiCompCorrection(np.array(values_allp), np.array(groups),
                                                                       alpha, nperm=nperm)
        print("cluster size {}: {}".format(bundles[b_idx], clusterFWE))

        pvalues = np.zeros(NR_POINTS)
        for jdx in range(NR_POINTS):
            values_controls = [values[s][b_idx][jdx] for s in subjects_A]
            values_patients = [values[s][b_idx][jdx] for s in subjects_B]
            pvalues[jdx] = scipy.stats.ttest_ind(values_controls, values_patients).pvalue
        sig_areas = get_significant_areas(pvalues, clusterFWE, alpha / multcomp)
        sig_areas = sig_areas * np.array(data["fa"]).max()
        sig_areas[sig_areas == 0] = np.array(data["fa"]).min()
        axes[i].plot(range(len(sig_areas)), sig_areas, color="red", linestyle=":")

    plt.tight_layout()
    plt.savefig(output_path, dpi=200)


def main():
    parser = argparse.ArgumentParser(description="Plot tractometry results and show significant areas.",
                                     epilog="Written by Jakob Wasserthal.")
    parser.add_argument("-i", metavar="subjects_file_path", dest="subjects_file",
                        help="txt file containing path of subjects", required=True)
    parser.add_argument("-o", metavar="plot_path", dest="output_path",
                        help="output png file containing plots", required=True)
    args = parser.parse_args()

    base_path, subjects_A, subjects_B = parse_subjects_file(args.subjects_file)

    print("Number of subjects:")
    print("  group A: {}".format(len(subjects_A)))
    print("  group B: {}".format(len(subjects_B)))

    bundles = dataset_specific_utils.get_bundle_names("All_tractometry")[1:]

    # Define bundles you want to plot
    selected_bundles = bundles
    # selected_bundles = ["CST_right", "UF_left"]

    values = {}
    for subject in subjects_A + subjects_B:
        raw = np.loadtxt(base_path.replace("SUBJECT_ID", subject), delimiter=";", skiprows=1).transpose()
        # legacy: only needed for HCP
        # values[subject] = np.array([raw[idx][1:-1] for idx, bundle in enumerate(bundles)])  # 100->98
        values[subject] = raw


    # Runtime:
    # - 72 bundles 1000 permutations: ~4min
    # - 72 bundles 10000 permutations: ~7min

    alpha = 0.05
    multcomp = 1  # multiple comparison between bundles correction (state number of bundles)
    nperm = 10000
    plot_tractometry_with_pvalue(values, subjects_A, subjects_B, bundles, selected_bundles, args.output_path,
                                 alpha, multcomp=multcomp, nperm=nperm)


if __name__ == '__main__':
    main()
